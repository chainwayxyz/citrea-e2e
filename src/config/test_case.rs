use std::{env, path::PathBuf, time::Duration};

use tempfile::TempDir;

use super::CitreaMode;
use crate::utils::generate_test_id;

#[derive(Clone, Default)]
pub struct TestCaseEnv {
    pub test: Vec<(&'static str, &'static str)>,
    pub full_node: Vec<(&'static str, &'static str)>,
    pub sequencer: Vec<(&'static str, &'static str)>,
    pub batch_prover: Vec<(&'static str, &'static str)>,
    pub light_client_prover: Vec<(&'static str, &'static str)>,
    pub bitcoin: Vec<(&'static str, &'static str)>,
    pub clementine: Vec<(&'static str, &'static str)>,
}

impl TestCaseEnv {
    // Base env that should apply to every test cases
    fn base_env() -> Vec<(&'static str, &'static str)> {
        vec![("NO_COLOR", "1"), ("PARALLEL_PROOF_LIMIT", "1")]
    }

    fn test_env(&self) -> Vec<(&'static str, &'static str)> {
        [Self::base_env(), self.test.clone()].concat()
    }

    pub fn sequencer(&self) -> Vec<(&'static str, &'static str)> {
        [self.test_env(), self.sequencer.clone()].concat()
    }

    pub fn batch_prover(&self) -> Vec<(&'static str, &'static str)> {
        [self.test_env(), self.batch_prover.clone()].concat()
    }

    pub fn light_client_prover(&self) -> Vec<(&'static str, &'static str)> {
        [self.test_env(), self.light_client_prover.clone()].concat()
    }

    pub fn full_node(&self) -> Vec<(&'static str, &'static str)> {
        [self.test_env(), self.full_node.clone()].concat()
    }

    pub fn bitcoin(&self) -> Vec<(&'static str, &'static str)> {
        [self.test_env(), self.bitcoin.clone()].concat()
    }

    pub fn clementine(&self) -> Vec<(&'static str, &'static str)> {
        [self.test_env(), self.clementine.clone()].concat()
    }
}

#[derive(Clone, Debug)]
pub struct TestCaseConfig {
    pub n_nodes: usize,
    pub with_sequencer: bool,
    pub with_full_node: bool,
    pub with_batch_prover: bool,
    pub with_light_client_prover: bool,
    pub with_citrea_cli: bool,
    /// This also enables postgres
    pub with_clementine: bool,
    /// > 0 is required for clementine
    pub n_verifiers: u8,
    /// > 0 is required for clementine
    pub n_operators: u8,
    pub timeout: Duration,
    pub dir: PathBuf,
    pub docker: TestCaseDockerConfig,
    /// Either a relative dir from workspace root, i.e. "./resources/genesis/devnet"
    /// Or an absolute path.
    /// Defaults to `resources/genesis/bitcoin-regtest`
    pub genesis_dir: Option<String>,
    /// Path to Clementine resources directory.
    ///
    /// Expected to have `certs` directory with `ca`, `aggregator`, `client`,
    /// `server` subdirectories (generated by automatically if missing).
    /// Expected to have regtest_paramset.toml file.  Defaults to
    /// `resources/clementine` if not set.
    pub clementine_dir: Option<String>,
    pub test_id: String,
    pub mode: CitreaMode,
}

impl Default for TestCaseConfig {
    fn default() -> Self {
        let test_id = generate_test_id();
        TestCaseConfig {
            n_nodes: 1,
            with_sequencer: true,
            with_batch_prover: false,
            with_light_client_prover: false,
            with_full_node: false,
            with_citrea_cli: false,
            n_verifiers: 0,
            n_operators: 0,
            with_clementine: false,
            timeout: Duration::from_secs(60),
            dir: std::env::var("TEST_OUT_DIR")
                .map_or_else(
                    |_| {
                        TempDir::new()
                            .expect("Failed to create temporary directory")
                            .into_path()
                    },
                    PathBuf::from,
                )
                .join(test_id.clone()),
            docker: TestCaseDockerConfig::default(),
            genesis_dir: None,
            clementine_dir: None,
            test_id,
            mode: CitreaMode::Dev,
        }
    }
}

impl TestCaseConfig {
    pub fn docker_enabled(&self) -> bool {
        self.docker.enabled() || self.with_clementine
    }
}

#[derive(Clone, Debug)]
pub struct TestCaseDockerConfig {
    pub bitcoin: bool,
    pub citrea: bool,
    // TODO: need to add support for this
    pub clementine: bool,
}

impl Default for TestCaseDockerConfig {
    fn default() -> Self {
        TestCaseDockerConfig {
            bitcoin: parse_bool_env("TEST_BITCOIN_DOCKER").unwrap_or(true),
            citrea: parse_bool_env("TEST_CITREA_DOCKER").unwrap_or(false),
            clementine: parse_bool_env("TEST_CLEMENTINE_DOCKER").unwrap_or(false),
        }
    }
}

impl TestCaseDockerConfig {
    pub fn enabled(&self) -> bool {
        self.bitcoin || self.citrea || self.clementine
    }
}

pub fn parse_bool_env(key: &str) -> Option<bool> {
    env::var(key)
        .ok()
        .map(|v| &v == "1" || &v.to_lowercase() == "true")
}
